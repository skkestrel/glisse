#include "../data.h"
#include "../util.h"
#include <sys/stat.h>

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"
#include "../cxxopts.h"
#pragma GCC diagnostic pop

#include <iostream>
#include <string>
#include <fstream>
#include <sstream>

int64_t bsearch(std::istream& f, size_t npa, uint32_t partnum, size_t stride)
{
	int64_t base = f.tellg();
	int64_t left = 0;
	int64_t right = npa - 1;

	while (left <= right)
	{
		int64_t mid = left + (right - left) / 2;
		f.seekg(base + mid * stride);

		uint32_t id;
		sr::data::read_binary<uint32_t>(f, id);
		if (id == partnum)
		{
			return true;
		}
		else if (id > partnum)
		{
			right = mid - 1;
		}
		else
		{
			left = mid + 1;
		}
	}

	return false;
}

void process(std::istream& input, std::ofstream& outfile, const std::vector<uint32_t>& particles, bool killplanets, int64_t splitbytes, size_t& outnum, const std::string& outpath)
{
	while (true)
	{
		double time;
		sr::data::HostParticleSnapshot paout;
		sr::data::HostPlanetSnapshot pl;

		sr::data::load_binary_track(input, pl, paout, time, killplanets, true);

		if (!input) break;

		if (killplanets)
		{
			pl.n_alive = pl.n = 1;
		}

		input.seekg(-sr::data::TRACK_PARTICLE_STRIDE * paout.n, std::ios_base::cur);

		for (size_t j = 0; j < particles.size(); j++)
		{
			int64_t position = input.tellg();
			if (bsearch(input, paout.n, particles[j], sr::data::TRACK_PARTICLE_STRIDE))
			{
				paout.r.resize(paout.r.size() + 1);
				paout.v.resize(paout.v.size() + 1);
				paout.id.resize(paout.id.size() + 1);

				sr::data::read_binary<uint32_t>(input, paout.id[paout.r.size() - 1]);
				sr::data::read_binary<double>(input, paout.r[paout.r.size() - 1].x);
				sr::data::read_binary<double>(input, paout.r[paout.r.size() - 1].y);
				sr::data::read_binary<double>(input, paout.r[paout.r.size() - 1].z);
				sr::data::read_binary<double>(input, paout.v[paout.r.size() - 1].x);
				sr::data::read_binary<double>(input, paout.v[paout.r.size() - 1].y);
				sr::data::read_binary<double>(input, paout.v[paout.r.size() - 1].z);
			}

			input.seekg(position);
		}
		input.seekg(sr::data::TRACK_PARTICLE_STRIDE * paout.n, std::ios_base::cur);
		paout.n_alive = paout.n = paout.r.size();

		sr::data::save_binary_track(outfile, pl, paout, time, false);

		if (splitbytes != 0 && outfile.tellp() > static_cast<int>(splitbytes))
		{
			std::ostringstream ss;

			ss << outpath;
			if (outpath[outpath.size() - 1] != '/') ss << '/';
			ss << "track." << outnum++ << ".out";

			outfile = std::ofstream(ss.str(), std::ios_base::binary);
		}
	}
}

int main(int argc, char** argv)
{
	cxxopts::Options options("prune-track", "Prune large track files generated by simulations");
	options.add_options()
		("i,input", "Input file or directory (with -f)", cxxopts::value<std::string>())
		("o,output", "Output file or directory (with -s)", cxxopts::value<std::string>())
		("f,split-input", "Read from input folder")
		("s,split-output", "Split output every n bytes", cxxopts::value<uint64_t>())
		("P,no-planets", "Throw away planets")
		("w,watch-particles", "Watch particles (comma separated list)", cxxopts::value<std::string>());

	options.parse_positional({ "input", "output" });
	auto result = options.parse(argc, argv);

	if (result.count("i") == 0)
	{
		std::cout << "Required flag -i" << std::endl;
		return -1;
	}
	if (result.count("o") == 0)
	{
		std::cout << "Required flag -o" << std::endl;
		return -1;
	}

	std::vector<uint32_t> particles;
	if (result.count("w") > 0)
	{
		std::istringstream ss(result["w"].as<std::string>());
		std::string token;

		while (std::getline(ss, token, ','))
		{
			particles.push_back(static_cast<uint32_t>(std::stoul(token)));
		}
	}

	std::sort(particles.begin(), particles.end());

	uint64_t splitbytes = 0;
	if (result.count("s") > 0)
	{
		splitbytes = result["s"].as<uint64_t>();
	}

	bool killplanets = false;
	if (result.count("P") > 0)
	{
		killplanets = true;
	}

	std::string inpath = result["i"].as<std::string>();
	std::string outpath = result["o"].as<std::string>();

	if (!sr::util::is_dir_empty(outpath))
	{
		std::cout << "Output folder is not empty! Do you want to continue?" << std::endl;
		std::cout << "Type \"Yes\" exactly as shown to continue: ";
	
		std::string s;
		std::getline(std::cin, s);

		if (s != "Yes") return -1;
	}

	std::ostringstream ss;

	if (splitbytes > 0)
	{
		mkdir(outpath.c_str(), ACCESSPERMS);

		ss << outpath;
		if (outpath[outpath.size() - 1] != '/') ss << '/';
		ss << "track.0.out";
	}
	else
	{
		ss << outpath;
	}

	size_t outnum = 1;
	std::ofstream outfile(ss.str(), std::ios_base::binary);

	if (result.count("f") > 0)
	{
		for (size_t i = 0; true; i++)
		{
			ss = std::ostringstream();
			ss << inpath;
			if (inpath[inpath.size() - 1] != '/') ss << '/';
			ss << "track." << i << ".out";

			std::cout << "Reading " << ss.str() << std::endl;

			if (!sr::util::does_file_exist(ss.str()))
			{
				if (i == 0)
				{
					std::cout << "Error: empty directory" << std::endl;
					return -1;
				}
				else
				{
					std::cout << i << " files read" << std::endl;
					return 0;
				}
			}

			std::ifstream input(ss.str(), std::ios_base::binary);

			process(input, outfile, particles, killplanets, splitbytes, outnum, outpath);
		}
	}
	else
	{
		if (!sr::util::does_file_exist(inpath))
		{
			std::cout << "Error: input file " << inpath << "does not exist" << std::endl;
			return -1;
		}

		std::ifstream input(inpath, std::ios_base::binary);

		process(input, outfile, particles, killplanets, splitbytes, outnum, outpath);
	}

	return 0;
}
